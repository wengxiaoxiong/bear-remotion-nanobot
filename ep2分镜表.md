# EP2 分镜表：用1%的代码复刻 Clawdbot（2/3）——想→做→看→再想

> 总时长目标：10-10.5 分钟
> 类型说明：**remotion 动画** / **remotion PPT**（简约排版） / **录频** / **截图**（可多选）
> 本集定位：**严谨专业**，深入拆解 Agent Loop 核心机制，分镜中在关键流程处加入**伪代码**（基于 NanoBot 源码），便于观众理解实现逻辑。
> **需要准备的素材**：该镜头所需截图、图标、录屏、文案等。
> **本集核心主题**：EP1 用一个镜头带过的"循环"——Agent Loop——是整个架构最核心的引擎。本集拆透它，并通过一个「调研→做 PPT→发群」的完整案例，展示 Agent 如何调用记忆、技能、本地文件和操作系统工具来完成复杂任务。

---

## 一、分镜总表

### 开场（0:00-0:55）

| # | 逐字稿摘要 | 时间 | 类型 | 画面描述 | 伪代码/逻辑 | 素材 |
|---|------------|------|------|----------|------------|------|
| 1 | 大家好，我是熊老板。上一集我们聊了 Clawdbot 这种 Agent 为什么看起来那么聪明——它有 SystemPrompt、有 Workspace 工作区、还有 HeartBear 心跳机制。但是！有一个最核心的环节，我上次其实只用一句话就带过了。 | 0:00-0:18 | remotion PPT | 主讲人头像；系列标题「用1%的代码复刻 Clawdbot」；副标题「2/3」；简约深色背景。 | — | 头像/Logo；系列标题定稿 |
| 2 | 就是这个——「Agent Loop」。这里面其实藏着特别多细节：它是怎么调用工具的？它怎么跟工作区交互？这一集我们把它拆开来讲。 | 0:18-0:35 | remotion 动画 | 「循环」那一步高亮放大、脉动效果；其余步骤变灰。旁注「一句话带过 → 其实是核心」。 | — | EP1 管线图复用 |
| 3 | 所以今天这一集，我们全程高能，专注拆解 NanoBot 的 Agent Loop。看完这一集，你就能彻底搞懂，一个跑在操作系统上的 Agent，到底是怎么 work 的。 | 0:35-0:55 | remotion PPT + 动画 | 本集标题「想→做→看→再想」大字居中；下方四个关键词依次亮起：「本地文件」「操作系统」「长期记忆」「可学习」；底部：「不是 ChatBot，是 OS-level Agent」。 | — | 无 |

### Part 1：Agent Loop——从上下文到循环（0:55-5:30）

#### 1A. Agent 每次「看到」什么？（0:55-3:20）

| # | 逐字稿摘要 | 时间 | 类型 | 画面描述 | 伪代码/逻辑 | 素材 |
|---|------------|------|------|----------|------------|------|
| 4 | 当你在飞书给 Clawdbot 发一条消息，Agent 收到后，其实主要就在死磕三件事儿：第一，组装上下文；第二，调用 LLM；第三，执行工具。这三步构成了一个循环。 | 0:55-1:15 | remotion 动画 | 五层管线图从 EP1 回来，第三层 Agent Loop 高亮放大。右侧循环图：三个节点「组装上下文」→「调 LLM」→「执行工具」形成环形，出口线「LLM 说做完了 → 退出」。 | — | EP1 管线图改版 |
| 5 | 我们先回顾一下第一步：组装上下文。简单说，就是把 Workspace 里的各种文件，拼成一个巨大的 System Prompt。这个过程，我们可以把它拆成四层来看。 | 1:15-1:28 | remotion 动画 | 标题「Agent 每次看到什么？」；Workspace 文件树在左，右侧一个「System Prompt」长条被分成四层（待逐层展开）。 | — | Workspace 文件树图标（复用 EP1） |
| 6 | **【长镜头：四层上下文组装 - 112秒连续动画】** 第一层：身份。我是谁？现在几点？我跑在 macOS 上还是 Linux 上？我的工作区在哪？这一层非常关键，**如果没有它，Agent 醒来连自己在哪台机器上都不知道**，更别提干活了。第二层：规范。AGENTS.md 规定行为，SOUL.md 定义人格，USER.md 记录你的偏好。**如果没有这一层，Agent 的性格就会飘忽不定**。这一秒是严谨工程师，下一秒可能就变成复读机了。这就是 Workspace 的灵活性——想改性格？不用改代码，改个文件就行。第三层：记忆。Workspace 里有个 MEMORY.md。**如果没有这一层，它就是个只有七秒记忆的金鱼**。比如你上次说「周报只要摘要」，Agent 会自动把这条写进 MEMORY.md。下次它一醒来，看到这条记忆，就不需要你再废话一遍了。第四层：技能摘要。它会什么？deep-research？写 PPT？查 Github？所有技能都会列在这里。**如果没有这一层，它就是个失忆专家**。它得先知道「我有这些本事」，具体怎么用，用到的时候再去查说明书。好，身份、规范、记忆、技能，这四层一叠，就是一个完整的 System Prompt。再加上之前的对话历史和你刚发的消息，打包发给 LLM。**这就是 Agent 每次「睁眼」看到的所有信息。** 来，我们看看代码里它长什么样。 | 1:28-3:20 | remotion 动画（单 Composition 长镜头） | **Remotion 实现方式**：一个 Composition，通过 frame 时间轴控制 112 秒（3360帧@30fps）的连续动画。画面中央保持 System Prompt 长条结构，四层依次从下往上堆叠展开。**时间轴规划**：frame 0-60（2秒）：第一层「身份 Identity」从底部亮起，展示关键信息，底部浮出消化句；frame 60-180（4秒）：第二层「规范 Bootstrap」平滑上移亮起，文件图标依次飞入；frame 180-300（4秒）：第三层「记忆 Memory」上移亮起，展示写入读取循环；frame 300-420（4秒）：第四层「技能 Skills」上移亮起，技能标签依次出现；frame 420-480（2秒）：四层合拢，追加「对话历史」和「当前消息」；frame 480-540（2秒）：伪代码块渐入。**技术要点**：使用 `interpolate` 控制透明度/位移，`spring` 控制弹性动画，通过 `useCurrentFrame()` 精确控制每帧状态。**优势**：视觉连续，无切镜感；**注意**：代码复杂度较高，需要仔细规划时间轴。 | `messages = [\n  {"role": "system", "content": system_prompt},\n  ...session.history[-50:],\n  {"role": "user", "content": current_msg}\n]` | 无 |

#### 1B. 循环怎么转？（3:20-5:30）

| # | 逐字稿摘要 | 时间 | 类型 | 画面描述 | 伪代码/逻辑 | 素材 |
|---|------------|------|------|----------|------------|------|
| 11 | 上下文组装好了，接下来进入心脏地带——Agent Loop 迭代循环。这块逻辑是整个 Agent 的灵魂，我来一步一步拆给你看。 | 3:20-3:30 | remotion PPT | 标题「Agent Loop 迭代」；副标题「整个 Agent 的心脏」。 | — | 无 |
| 12 | **【一镜到底：Agent Loop 完整循环拆解】** 第一步：把刚才打包好的 messages 发给 LLM，顺便附上一张工具清单——告诉它：「哥们，你有这些工具可以用」。然后，坐等 LLM 回复。第二步：检查回复。LLM 一般有两种回法。一种是直接给一段话，意思是「我想好了，这是答案」。如果是这种，没 tool call，那就说明任务结束，**直接退出循环**，把话转给用户。但如果有 tool call，好戏才刚开始。先解释下，**工具就是 Agent 的「手」**——读文件、跑命令、搜网页。NanoBot 把所有工具都写在一张清单里。当 LLM 觉得光靠嘴不行，得动手时，它就会回一个 tool call：「我要用 read_file，读一下 ~/notes/todo.md」。系统拿到这个请求，哐当一下执行工具，拿到结果。然后——注意这步最关键——**把结果塞回 messages 里，再次喂给 LLM**。这结果不是给用户看的，是给 LLM 接着思考用的。来看看代码里这步长啥样。结果喂回去，循环回到顶部，LLM 再次审视——「结果有了，还要干啥？」。也许它觉得信息不够，再调个工具；也许觉得够了，直接给结论。**什么时候停，全看 LLM 自己心情。** Agent Loop 的本质，其实就是给 LLM 发了一张草稿纸。ChatGPT 是闭卷考试，一次定生死；Agent 是开卷考试，允许你打草稿、查资料、甚至算错了重算。**ChatBot 聊一轮就结束，Agent 是跑 N 轮，直到把事儿办成。** | 3:30-5:30 | remotion 动画（一镜到底） | **连续动画流程**：画面中央保持 Agent Loop 循环图结构，通过平滑的动画展示完整循环过程。具体流程：①循环图第一步高亮：messages + 工具清单 → LLM → response，标注「第一步：发送消息和工具清单」；②分支判断节点平滑展开：response → 「有 tool_call?」→ 否分支（绿色箭头）→ 「退出循环，返回文本」，标注「无 tool call = 任务完成」；③是分支展开：先展示工具清单概念（列表 `[read_file, exec, web_search, ...]`，标注「Agent 所有能力的统一清单」），然后展示 tool call 示例（`{name: "read_file", arguments: {path: "~/notes/todo.md"}}`，标注「工具名 + 参数」）；④执行流程动画：tool_call → 找到工具 → 执行 → result → **追加到 messages**（高亮「喂回 LLM」），过渡句「来看看代码里这步长啥样」后，画面下方渐入伪代码块；⑤循环回到顶部：强调箭头 tool result → messages → **回到循环顶部** → 再次调 LLM → 分支，循环动画完整转一圈，高亮「LLM 自己决定停不停」；⑥对比总结：循环图继续转动，屏幕分裂为左右对比（左边 ChatBot 一次变红 Fail，右边 Agent Loop 第一次变红回退、第二次变绿 Success），金句浮现「允许犯错、回看、再试」。**全程无切镜，通过循环图的动态展开和分支展示完成完整流程。** | `for tc in response.tool_calls:\n  result = await tools.execute(\n    tc.name, tc.arguments\n  )\n  messages.append({\n    "role": "tool",\n    "tool_call_id": tc.id,\n    "content": result\n  })` | 无 |

### Part 2：为什么是 OS-level Agent？（5:30-7:20）

| # | 逐字稿摘要 | 时间 | 类型 | 画面描述 | 伪代码/逻辑 | 素材 |
|---|------------|------|------|----------|------------|------|
| 18 | 刚才说 Agent 有一堆工具，能读写、能跑命令。但有个致命的问题还没说——**这些工具，到底跑在哪？** | 5:30-5:40 | remotion PPT | 过渡句居中：「这些工具跑在哪？」。承上启下，不是开新话题。 | — | 无 |
| 19 | **【一镜到底：OS-level Agent 定位与风险说明】** NanoBot 是跑在你自己的电脑，或者你自己的服务器上的。它操作的不是什么云端沙箱，而是**你实实在在的本地文件系统**。这和 Manus 那些云端 Agent 有本质区别。它们跑在远程容器里，读不到你桌面的文件。NanoBot 不一样，你的代码、你的笔记、你装的 Python，它全能碰。**但是，这里要强调一下——OS-level Agent 是有风险的。**它能直接操作你的文件系统，能跑任意命令，这意味着如果它出错了，或者被恶意指令操控，可能会造成数据丢失、系统破坏等严重后果。**所以，在生产环境，我们会使用沙盒。**沙盒可以隔离 Agent 的执行环境，限制它的权限，即使出错也不会影响到你的主系统。沙盒有多种实现方式，比如 E2B、Docker 容器、或者专门的隔离环境。这些我们后面会详细讲解。**但现阶段，基于 Mac Mini 或者个人电脑的 OS-level Agent，最大的优势就是能方便地读取你的上下文和 Workspace**——它能直接访问你的文件、你的配置、你的工作环境，这种无缝集成是云端沙箱做不到的。 | 5:40-6:50 | remotion 动画（一镜到底） | **连续动画流程**：画面通过平滑过渡展示 OS-level Agent 的定位、风险和解决方案。具体流程：①左右对比展开：左「云端沙箱 Agent」→ 远程容器，和用户文件之间画叉号（断开），标注「无法访问本地文件」；右「OS-level Agent (NanoBot)」→ 直接在用户机器上，和用户文件之间画连接线（打勾），标注「你的文件、你的工具、你的环境」；②风险警告平滑出现：画面变红，警告标识从右侧滑入「⚠️ 风险：直接操作系统，可能造成数据丢失」，停留2秒；③解决方案分层展示：画面分层动画，上层「生产环境」→ 沙盒图标（E2B、Docker 等标签）依次出现，标注「隔离、安全」；下层「开发/个人环境」→ Mac Mini/个人电脑图标出现，标注「方便读取上下文和 Workspace」；中间箭头「生产用沙盒，开发用 OS-level」连接两层。**全程无切镜，通过画面分层和颜色变化完成风险说明和解决方案展示。** | — | 云/本地对比图标；警告图标；沙盒图标；Mac Mini/电脑图标 |
| 21 | 来看看它的武器库。文件操作四件套：增删改查，动的是你硬盘上的真文件。exec：直接跑 Shell 命令——你电脑装了 git、gh、curl，它就能用。还有搜网页的、发 Telegram 的、甚至派发子任务的。 | 6:50-7:10 | remotion 动画 | 九宫格展示九个工具，按类别分组依次亮起：文件(4) → Shell(1) → Web(2) → 通信(1) → 子任务(1)。exec 旁标注「你装了什么就能用什么」。文件操作旁标注「本地磁盘」。 | — | 九个工具图标 |
| 22 | 这九个工具，全是操作系统级别的能力。**这就是为啥它能干真活儿——它不是陪你聊天的，它是能帮你读文件、跑脚本、真正做交付的。**当然，记住我们刚才说的，生产环境记得用沙盒。 | 7:10-7:20 | remotion PPT | 金句「不是帮你聊两句，而是帮你做交付」；九宫格全部亮起。底部小字提醒：「生产环境 → 沙盒隔离」。 | — | 无 |

### Part 3：完整走一遍——从调研到交付（7:20-9:35）

| # | 逐字稿摘要 | 时间 | 类型 | 画面描述 | 伪代码/逻辑 | 素材 |
|---|------------|------|------|----------|------------|------|
| 23 | 理论讲完了，咱们来个真刀真枪的实战。假设你在 Telegram 上跟 Agent 说：「帮我调研下 AI Agent 最新进展，做个 PPT，发到群里」。就这一句话。Agent 背后要跑多少轮？每一轮都干了啥？ | 7:20-7:38 | remotion 动画 | 模拟 Telegram 消息气泡：用户发出指令。底部提问：「几轮循环？用了什么工具？」。 | — | Telegram 界面样式 |
| 24 | **【一镜到底：上下文组装与技能准备】** 消息进 Loop。第一件事，组装上下文。这里最神的是第三层 Memory。它在 MEMORY.md 里看到了一条记忆：「用户最近关注多模态大模型、RAG 优化」。**它不是从零开始瞎调研——它记得你关心什么。** 同时，技能栏里亮着 deep-research。Agent 此时还不知道具体怎么用，但它知道「我有这个技能，随时待命」。好，Loop 开始。 | 7:38-8:08 | remotion 动画（一镜到底） | **连续动画流程**：画面保持上下文四层结构，通过快速回放和重点展开完成组装。具体流程：①上下文四层快速回放（简化版，1-2 秒过完前两层身份和规范），Memory 层高亮展开，显示 MEMORY.md 内容片段，标注「记忆让 Agent 不从零开始」，停留2秒；②技能摘要层平滑亮起，标注 deep-research (available)，标注「知道有，不知道怎么用——一会儿去读」，停留1秒；③画面过渡到 Loop 循环图，标注「Loop 开始」。**全程无切镜，通过快速回放和重点展开完成上下文组装展示。** | — | MEMORY.md 内容片段 |
| 26 | **【一镜到底：七轮循环完整案例】** **第一轮**。Agent 决定先读 deep-research 的说明书。调用 read_file，读取 SKILL.md。学会了调研方法论——先搜、再读、再整理。这就是「想→做→看」的第一圈。**第二轮**。脑子学会了，开始动手。结合你的偏好，Agent 调用 web_search 搜「AI Agent 2025 进展 多模态」。注意，它搜的词比你给的更精准，因为它懂你。**第三轮**。结果出来了，Agent 挑了一篇最相关的去抓。结果——啪，403 Forbidden，抓取失败。**第四轮**。LLM 看到报错，没崩。它很冷静地换了个源，重新 fetch。这次成了。**这就是 Loop 的意义——允许犯错，允许重试，它自己能兜底。** **第五轮**。Agent 还没完，它想看看你本地有没有相关笔记。于是调用 read_file，读了你硬盘上的 ~/research/notes。**这一步，云端 Agent 只有干瞪眼的份，只有 OS-level Agent 做得到。** **第六轮**。料齐了。Agent 整理内容，直接调用 exec，用你机器上的 python-pptx 库生成 PPT。文件直接存到了你的 ~/output 目录下。**第七轮**。PPT 搞定。Agent 调用 message 工具，把摘要和文件路径发回 Telegram 群。完事儿，LLM 给出最终回复，**循环结束**。你在群里收到消息：「老板，报告好了，文件在这，摘要如下……」 | 8:08-9:35 | remotion 动画（一镜到底） | **连续动画流程**：画面中央保持循环图结构，七轮循环依次展开，每轮通过平滑过渡和状态变化展示。具体流程：①第1轮：循环图第1圈高亮，LLM → read_file("skills/deep-research/SKILL.md") → 返回方法论 → 喂回 LLM，标注「第1轮：学习方法」，停留2秒；②第2轮：循环图第2圈高亮，LLM → web_search("AI Agent 2025 进展 多模态") → 搜索结果 → 喂回 LLM，高亮「搜索词 = 记忆偏好 + 任务需求」，停留2秒；③第3轮：循环图第3圈高亮，LLM → web_fetch(url1) → Error 403 → 喂回 LLM，屏幕闪红「抓取失败」，停留1.5秒；④第4轮：循环图第4圈高亮，LLM → 思考「换个源」→ web_fetch(url2) → 成功 → 喂回 LLM，屏幕变绿「重试成功」，高亮「允许犯错、允许重试」，停留2秒；⑤第5轮：循环图第5圈高亮，LLM → read_file("~/research/notes/agent-survey.md") → 本地笔记 → 喂回 LLM，高亮「本地文件 = 知识来源」，角标「云端 Agent 做不到」，停留2秒；⑥第6轮：循环图第6圈高亮，LLM → exec("python make_ppt.py ...") → "PPT 已生成" → 喂回 LLM，旁边 PPT 文件图标 + 本地路径，标注「你机器上的 Python 环境」，停留2秒；⑦第7轮：循环图第7圈高亮，LLM → message("调研报告已生成...") → 发送成功 → LLM 返回文本 → **退出循环**（绿色出口箭头），模拟 Telegram 群消息出现，停留2秒。**全程无切镜，通过循环图的连续转动和每轮的状态变化完成七轮完整展示。** | — | SKILL.md 片段；文件图标 + 本地磁盘标注；PPT 文件图标；Telegram 群消息样式 |
| 33 | 回头看一眼。你发了一条消息，它默默跑了七轮循环——中间还崩了一次，自己修好了。**从头到尾，没人多嘴问你一句，活儿就干完了。** | 9:35-9:50 | remotion 动画 | 七轮循环全景回放，特别高亮中间的红色失败和绿色重试。金句浮现：「一条消息，七轮循环，零次追问」。 | — | 无 |

### Part 4：总结与下集预告（9:50-10:30）

| # | 逐字稿摘要 | 时间 | 类型 | 画面描述 | 伪代码/逻辑 | 素材 |
|---|------------|------|------|----------|------------|------|
| 34 | 升维总结一下。今天讲的这套 Context Builder → LLM → Executor → Memory 结构，不光是 NanoBot，它是 90% Agent 系统的通用母板。你把这个看懂了，以后看什么 Agent 架构都是降维打击。 | 9:50-10:10 | remotion PPT | 抽象架构图：Context Builder → Planner → Executor → Memory Writer。金句「Agent 通用母板」。 | — | 抽象架构图 |
| 35 | 它真不是个聊天机器人。它跑在你机器上，读你的文件，用你的工具，记你的偏好。这就是为啥 OS-level Agent 比云端沙箱更有用——因为它就在你的主场作战。当然，记住我们说的，生产环境记得用沙盒。 | 10:10-10:20 | remotion PPT + 动画 | 三行并列：「读你的文件」「用你的工具」「记你的偏好」。底部金句「OS-level Agent > 云端沙箱」。小字提醒：「生产环境 → 沙盒」。 | — | 无 |
| 36 | 但是，光有 Loop 还不够。Agent 能干多大的事，取决于它的「技能」怎么扩展，它的「记忆」怎么流转。下一集，我们硬核拆解 Skill 声明式技能系统和记忆的生命周期。下集见！ | 10:20-10:30 | remotion PPT + 动画 | 下集预告：「Skill 声明式技能」+「记忆生命周期」；结尾「我们下集见」+ 关注提示。 | — | 下集封面或标题 |

---

## 二、伪代码汇总（供 Remotion 或字幕叠加使用）

### 上下文组装 — build_messages()（镜 6，一镜到底）

```text
// 四层拼装 System Prompt
system_prompt = ""
system_prompt += identity()          // 第一层：身份（名字、时间、OS、workspace、工具列表）
system_prompt += read("AGENTS.md")   // 第二层：行为规范
system_prompt += read("SOUL.md")     //        人格
system_prompt += read("USER.md")     //        用户偏好
system_prompt += read("MEMORY.md")   // 第三层：长期记忆（Agent 自己维护）
system_prompt += skills_summary()    // 第四层：技能摘要（名字+描述，按需读全文）

messages = [
  {"role": "system", "content": system_prompt},
  ...session.history[-50:],          // 最近 50 条对话历史
  {"role": "user", "content": current_msg}
]
```

### Agent Loop 核心循环 — _run_agent_loop()（镜 12，一镜到底）

```text
async function agent_loop(messages, tools, max_iterations=20):
  iteration = 0
  while iteration < max_iterations:
    iteration += 1

    // 1. 把 messages + 工具清单发给 LLM
    response = await llm.chat(messages, tools)

    // 2. LLM 返回了什么？
    if response.has_tool_calls:
      // 有 tool call → 执行工具，结果追加到 messages
      for tc in response.tool_calls:
        result = await tools.execute(tc.name, tc.arguments)
        messages.append({
          role: "tool",
          tool_call_id: tc.id,
          content: result       // 结果喂回 LLM，不是给用户
        })
      // 回到循环顶部 → LLM 再看一遍

    else:
      // 没有 tool call → LLM 认为做完了
      return response.content   // 退出循环，返回给用户

  return "已达到最大迭代次数"
```

### 完整案例七轮循环示意（镜 26，一镜到底）

```text
用户: "帮我调研 AI Agent 最新进展，做 PPT，发到工作群"

--- 上下文组装 ---
System Prompt 包含:
  Memory  → "用户关注：多模态大模型、Agent 架构、RAG"
  Skills  → deep-research (available), ppt-maker (available)

--- Agent Loop 开始 ---

Round 1 — 学方法:
  LLM → read_file("skills/deep-research/SKILL.md")
  结果 → 调研方法论（搜索→精读→分主题整理）

Round 2 — 搜索（搜索词结合记忆偏好）:
  LLM → web_search("AI Agent 2025 进展 多模态")
  结果 → 搜索结果列表

Round 3 — 精读（失败尝试）:
  LLM → web_fetch(url1)
  结果 → Error 403 Forbidden (抓取失败)

Round 4 — 精读（重试成功）:
  LLM → web_fetch(url2)
  结果 → 文章正文 (Agent 自动修正路线)

Round 5 — 读本地笔记（OS-level：云端 Agent 做不到）:
  LLM → read_file("~/research/notes/agent-survey.md")
  结果 → 用户此前的调研笔记

Round 6 — 生成 PPT（OS-level：用本地 Python 环境）:
  LLM → exec("python make_ppt.py --output ~/output/report.pptx")
  结果 → "PPT 已生成: ~/output/report.pptx"

Round 7 — 发送到群:
  LLM → message(channel="telegram", content="报告已生成...")
  LLM → 最终文本回复（无 tool_call）→ 退出循环
```

---

## 三、修订说明（基于评审反馈）

### 已修复的问题

| 问题 | 原版 | 修订后 |
|------|------|--------|
| **Part 1 密度太高** | 镜 6-11 连续六层新概念，无停顿 | 每层后加「消化句」（醒来第一件事 / 换个文件风格就变 / 不从零开始），给观众「啊我懂了」的瞬间 |
| **伪代码冷启动** | 镜 11 直接出现代码 | 镜 10/15 在代码出现前先说「来看看代码里长什么样」，给心理准备 |
| **Tool Registry 术语** | 镜 16 直接说「Tool Registry」 | 镜 14 用自然语言先引入：「Agent 把所有工具统一注册在一个清单里」，不用术语 |
| **Part 1/2 边界模糊** | Part 2 开头「Agent Loop 的做靠什么？靠工具」像开新话题 | Part 2 开头改为「刚才那些工具，跑在哪？」，承上启下 |
| **一镜到底优化** | 多个短分镜频繁切换，影响观看流畅度 | 合并关键段落为一镜到底：镜 6（原6-10，四层上下文组装）、镜 12（原12-17，Agent Loop 循环拆解）、镜 19（原19-20，OS-level Agent 定位与风险）、镜 24（原24-25，上下文组装与技能准备）、镜 26（原26-32，七轮循环完整案例）。通过平滑动画过渡和状态变化完成展示，减少切镜带来的打断感。 |

---

## 四、类型与节奏说明

- **remotion 动画**：Agent Loop 循环图（核心，多次复用并逐步展开）、上下文四层堆叠（每层有消化停顿）、OS-level vs 云端对比、九宫格工具全览、七轮案例序列图（主打动画，占时最长）。
- **remotion PPT**：开场介绍、小节过渡、金句（「ChatBot 走 1 轮，Agent 走 N 轮」「不是帮你聊两句，而是帮你做交付」「一条消息，七轮循环，零次追问」）、总结与预告。
- **伪代码**：仅在有过渡语之后出现，基于 NanoBot 源码简化；字体等宽、深色背景；每段不超过 10 行，保持可读性。
- **总镜头** 约 19 个（已合并多个分镜为一镜到底），总时长约 10:30；成片可通过合并短镜或微调语速落在 10–10.5 分钟。**一镜到底分镜**：镜 6（四层上下文组装）、镜 12（Agent Loop 循环拆解）、镜 19（OS-level Agent 定位与风险）、镜 24（上下文组装与技能准备）、镜 26（七轮循环完整案例）。

---

## 五、需要准备的素材清单

| 类型 | 内容 |
|------|------|
| 人物/品牌 | 熊老板i 头像或 Logo；系列标题定稿 |
| 界面 | Telegram 消息 UI（用户提问 + 群消息 Agent 回复，可 Remotion 仿制） |
| 图标 | 电脑/服务器（OS-level）、云（沙箱 Agent）、九个工具图标（文件×4/Shell/搜索/网页/消息/子任务）、PPT 文件图标、MEMORY.md / SKILL.md 文件图标 |
| 图表 | EP1 管线图改版（高亮 Agent Loop）、Agent Loop 循环图（核心复用，六轮标注版）、System Prompt 四层长条图、OS-level vs 云端对比图、九宫格工具全览 |
| 内容片段 | MEMORY.md 示例（用户关注方向）、SKILL.md 片段（deep-research 方法论）、Telegram 群消息模拟 |
| 复用 EP1 | Workspace 文件树简版、架构简图 |

---

## 六、系列节奏调整说明

| 集数 | 主题 | 定位 |
|------|------|------|
| EP1 | 为什么看起来智能 | Overall 概览：四维度 + Workspace + 消息的一生 |
| **EP2（本集）** | **Agent Loop 深度拆解** | **核心引擎**：上下文四层 + LLM-工具循环 + OS-level 能力 + 完整案例 |
| EP3 | Skill + 记忆 + 主动执行 | 扩展与精度：声明式技能 + Progressive Loading + 记忆生命周期 + Proactive |

---

## 七、本集核心卖点

1. **Agent Loop 逐步拆解**：不再一句"循环调 LLM"带过，而是分「上下文」和「循环」两段拆，每一步都有消化空间。
2. **OS-level Agent 定位**：明确区分于 Manus 等云端沙箱 Agent——跑在你的机器上，用你的文件和工具。
3. **记忆驱动决策**：案例中展示 Agent 读取 MEMORY.md 后，搜索词结合用户偏好——记忆不是摆设，而是影响每一步执行。
4. **Comprehensive 案例**：一条消息，七轮循环，五种工具——涵盖 Skill 读取、网络搜索、本地文件、Python 脚本、群消息发送。金句「一条消息，七轮循环，零次追问」。
